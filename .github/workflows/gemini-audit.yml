name: Weekly Security Audit

on:
  schedule:
    - cron: '0 16 * * 0' # 每周日 16:00 UTC (北京时间周一凌晨 00:00)
  workflow_dispatch: # 允许手动触发

permissions:
  contents: write
  issues: write

jobs:
  security-audit:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Check and Fix Lockfile
        run: |
          echo "=== 检查项目锁文件状态 ==="
          
          # 检查是否存在 overrides 配置不匹配问题
          if pnpm install --frozen-lockfile 2>&1 | grep -q "ERR_PNPM_LOCKFILE_CONFIG_MISMATCH"; then
            echo "🔧 发现锁文件配置不匹配，正在修复..."
            echo "执行: pnpm install --no-frozen-lockfile"
            pnpm install --no-frozen-lockfile
            echo "✅ 锁文件已更新并同步"
            echo "LOCKFILE_FIXED=true" >> $GITHUB_ENV
          else
            echo "✅ 锁文件状态正常，使用标准安装"
            pnpm install
            echo "LOCKFILE_FIXED=false" >> $GITHUB_ENV
          fi

      - name: Install Dependencies
        run: |
          echo "=== 安装项目依赖 ==="
          if [ "$LOCKFILE_FIXED" = "true" ]; then
            echo "锁文件已在上一步修复，依赖安装完成"
          else
            echo "执行标准依赖安装..."
            pnpm install
          fi

      - name: Install Gemini CLI
        run: |
          echo "安装 Gemini CLI..."
          npm install -g @google/gemini-cli
          echo "验证安装..."
          gemini --version || echo "Gemini CLI 版本检查失败"

      - name: Create output directories
        run: |
          mkdir -p .audit-reports
          mkdir -p public/data

      - name: Run Security Audit
        run: |
          echo "=== 运行安全审计 ==="
          pnpm audit --json > .audit-reports/pnpm-audit.json 2>&1 || true
          pnpm audit > .audit-reports/pnpm-audit.txt 2>&1 || true
          
          # 获取可修复的漏洞信息
          echo "=== 检查可自动修复的漏洞 ==="
          pnpm audit --fix --dry-run > .audit-reports/pnpm-audit-fix-preview.txt 2>&1 || true
          
          # 生成漏洞摘要
          echo "=== 生成漏洞摘要 ==="
          if [ -f ".audit-reports/pnpm-audit.json" ]; then
            echo "漏洞统计摘要:" > .audit-reports/security-summary.txt
            grep -o '"severity":"[^"]*"' .audit-reports/pnpm-audit.json | sort | uniq -c >> .audit-reports/security-summary.txt 2>/dev/null || echo "无法解析漏洞统计" >> .audit-reports/security-summary.txt
            echo "" >> .audit-reports/security-summary.txt
            echo "受影响的包:" >> .audit-reports/security-summary.txt
            grep -o '"name":"[^"]*"' .audit-reports/pnpm-audit.json | head -10 >> .audit-reports/security-summary.txt 2>/dev/null || echo "无受影响的包" >> .audit-reports/security-summary.txt
          fi

      - name: AI Auto-Fix Security Issues
        run: |
          echo "=== AI 自动修复安全问题 ==="
          
          # 检查是否有安全漏洞
          if [ -f ".audit-reports/pnpm-audit.txt" ] && grep -q "vulnerabilities" .audit-reports/pnpm-audit.txt; then
            echo "发现安全漏洞，开始 AI 自动修复流程..."
            
            # 备份当前的 package.json 和 pnpm-lock.yaml
            cp package.json package.json.backup 2>/dev/null || echo "未找到 package.json"
            cp pnpm-lock.yaml pnpm-lock.yaml.backup 2>/dev/null || echo "未找到 pnpm-lock.yaml"
            
            # 记录修复前的状态
            echo "修复前的漏洞状态:" > .audit-reports/fix-log.txt
            pnpm audit --json > .audit-reports/pre-fix-audit.json 2>&1 || true
            
            # 尝试多种修复策略
            echo "🔧 尝试自动修复安全漏洞..."
            
            # 策略1: 标准自动修复
            echo "策略1: 执行 pnpm audit --fix" >> .audit-reports/fix-log.txt
            pnpm audit --fix > .audit-reports/auto-fix-result.txt 2>&1
            FIX_EXIT_CODE=$?
            
            # 更新锁文件确保一致性
            echo "🔄 更新锁文件确保一致性..." >> .audit-reports/fix-log.txt
            pnpm install --no-frozen-lockfile > .audit-reports/lockfile-sync.txt 2>&1 || echo "锁文件同步失败" >> .audit-reports/fix-log.txt
            
            # 检查是否还有漏洞
            pnpm audit > .audit-reports/post-fix-check1.txt 2>&1 || true
            if grep -q "vulnerabilities" .audit-reports/post-fix-check1.txt; then
              echo "策略1未完全修复，尝试策略2" >> .audit-reports/fix-log.txt
              
              # 策略2: 更新所有依赖到最新版本
              echo "策略2: 更新依赖到最新版本" >> .audit-reports/fix-log.txt
              pnpm update > .audit-reports/update-result.txt 2>&1 || true
              
              # 更新锁文件
              pnpm install --no-frozen-lockfile > .audit-reports/lockfile-sync2.txt 2>&1 || true
              
              # 再次检查
              pnpm audit > .audit-reports/post-fix-check2.txt 2>&1 || true
              if grep -q "vulnerabilities" .audit-reports/post-fix-check2.txt; then
                echo "策略2未完全修复，尝试策略3" >> .audit-reports/fix-log.txt
                
                # 策略3: 强制修复
                echo "策略3: 强制修复 pnpm audit --fix --force" >> .audit-reports/fix-log.txt
                pnpm audit --fix --force > .audit-reports/force-fix-result.txt 2>&1 || true
                
                # 更新锁文件
                pnpm install --no-frozen-lockfile > .audit-reports/lockfile-sync3.txt 2>&1 || true
                
                # 最终检查
                pnpm audit > .audit-reports/post-fix-check3.txt 2>&1 || true
                if ! grep -q "vulnerabilities" .audit-reports/post-fix-check3.txt; then
                  FIX_EXIT_CODE=0
                  echo "策略3修复成功" >> .audit-reports/fix-log.txt
                fi
              else
                FIX_EXIT_CODE=0
                echo "策略2修复成功" >> .audit-reports/fix-log.txt
              fi
            else
              echo "策略1修复成功" >> .audit-reports/fix-log.txt
            fi
            
            # 检查修复结果
            echo "修复命令退出码: $FIX_EXIT_CODE" >> .audit-reports/fix-log.txt
            
            if [ $FIX_EXIT_CODE -eq 0 ]; then
              echo "✅ 自动修复成功" >> .audit-reports/fix-log.txt
              
              # 重新运行审计检查修复效果
              pnpm audit --json > .audit-reports/post-fix-audit.json 2>&1 || true
              pnpm audit > .audit-reports/post-fix-audit.txt 2>&1 || true
              
              # 检查是否还有漏洞
              if grep -q "vulnerabilities" .audit-reports/post-fix-audit.txt 2>/dev/null; then
                REMAINING_VULNS=$(grep -o "[0-9]* vulnerabilities" .audit-reports/post-fix-audit.txt | head -1)
                echo "⚠️ 仍有未修复的漏洞: $REMAINING_VULNS" >> .audit-reports/fix-log.txt
                
                # AI 智能修复尝试
                echo "🤖 启动 AI 智能修复..." >> .audit-reports/fix-log.txt
                
                REMAINING_AUDIT=$(cat .audit-reports/post-fix-audit.txt 2>/dev/null || echo "无审计结果")
                REMAINING_JSON=$(cat .audit-reports/post-fix-audit.json 2>/dev/null || echo "{}")
                
                AI_ANALYSIS_PROMPT="请分析以下 pnpm audit 结果，并提供具体的修复命令。只返回可执行的 pnpm 命令，每行一个命令：

                ## 审计结果
                \`\`\`
                $REMAINING_AUDIT
                \`\`\`

                ## JSON 详情
                \`\`\`
                $REMAINING_JSON
                \`\`\`

                请分析漏洞并返回具体的修复命令，格式如下：
                pnpm add package@version
                pnpm update package

                只返回命令，不要其他解释。"

                # 获取 AI 建议的修复命令
                timeout 60s bash -c "echo '$AI_ANALYSIS_PROMPT' | gemini" > .audit-reports/ai-fix-commands.txt 2>&1 || echo "AI 命令生成失败" > .audit-reports/ai-fix-commands.txt
                
                # 执行 AI 建议的命令
                if [ -f ".audit-reports/ai-fix-commands.txt" ] && ! grep -q "失败" .audit-reports/ai-fix-commands.txt; then
                  echo "🚀 执行 AI 建议的修复命令..." >> .audit-reports/fix-log.txt
                  
                  while IFS= read -r cmd; do
                    # 过滤出有效的 pnpm 命令
                    if echo "$cmd" | grep -q "^pnpm "; then
                      echo "执行命令: $cmd" >> .audit-reports/fix-log.txt
                      eval "$cmd" >> .audit-reports/ai-fix-execution.txt 2>&1 || echo "命令执行失败: $cmd" >> .audit-reports/fix-log.txt
                    fi
                  done < .audit-reports/ai-fix-commands.txt
                  
                  # 更新锁文件以避免部署时的配置不匹配错误
                  echo "🔄 更新 pnpm 锁文件..." >> .audit-reports/fix-log.txt
                  pnpm install --no-frozen-lockfile >> .audit-reports/lockfile-update.txt 2>&1 || echo "锁文件更新失败" >> .audit-reports/fix-log.txt
                  
                  # 最终验证
                  pnpm audit > .audit-reports/final-audit-check.txt 2>&1 || true
                  if ! grep -q "vulnerabilities" .audit-reports/final-audit-check.txt; then
                    echo "🎉 AI 智能修复成功！" >> .audit-reports/fix-log.txt
                    echo "AUTO_FIX_STATUS=complete" >> $GITHUB_ENV
                  else
                    echo "AUTO_FIX_STATUS=partial" >> $GITHUB_ENV
                  fi
                else
                  echo "AUTO_FIX_STATUS=partial" >> $GITHUB_ENV
                fi
              else
                echo "🎉 所有漏洞已修复" >> .audit-reports/fix-log.txt
                echo "AUTO_FIX_STATUS=complete" >> $GITHUB_ENV
              fi
              
              # 最终锁文件同步，确保部署兼容性
              echo "🔄 最终锁文件同步..." >> .audit-reports/fix-log.txt
              pnpm install --no-frozen-lockfile > .audit-reports/final-lockfile-sync.txt 2>&1 || echo "最终锁文件同步失败" >> .audit-reports/fix-log.txt
              
              # 验证项目构建状态
              echo "🏗️ 验证项目构建状态..." >> .audit-reports/fix-log.txt
              pnpm run build --dry-run > .audit-reports/build-check.txt 2>&1 || echo "构建验证失败或不支持 --dry-run" >> .audit-reports/fix-log.txt
              
              # 检查依赖变更
              echo "" >> .audit-reports/fix-log.txt
              echo "依赖变更:" >> .audit-reports/fix-log.txt
              if [ -f "package.json.backup" ]; then
                diff package.json.backup package.json >> .audit-reports/fix-log.txt 2>&1 || echo "package.json 有变更" >> .audit-reports/fix-log.txt
              fi
              
              echo "SECURITY_FIXED=true" >> $GITHUB_ENV
              
            else
              echo "❌ 自动修复失败，退出码: $FIX_EXIT_CODE" >> .audit-reports/fix-log.txt
              echo "错误详情:" >> .audit-reports/fix-log.txt
              cat .audit-reports/auto-fix-result.txt >> .audit-reports/fix-log.txt
              
              # 恢复备份文件
              mv package.json.backup package.json 2>/dev/null || true
              mv pnpm-lock.yaml.backup pnpm-lock.yaml 2>/dev/null || true
              
              echo "AUTO_FIX_STATUS=failed" >> $GITHUB_ENV
              echo "SECURITY_FIXED=false" >> $GITHUB_ENV
            fi
            
          else
            echo "未发现安全漏洞，跳过修复步骤"
            echo "AUTO_FIX_STATUS=not_needed" >> $GITHUB_ENV
            echo "SECURITY_FIXED=false" >> $GITHUB_ENV
          fi

      - name: Generate AI Security Report
        run: |
          echo "=== 使用 AI 生成安全审计报告 ==="
          
          TIMESTAMP=$(date +%s)
          CURRENT_DATE=$(date '+%Y-%m-%d')
          
          # 准备审计数据
          SECURITY_ISSUES=$(cat .audit-reports/pnpm-audit.txt 2>/dev/null || echo "无安全问题")
          SECURITY_SUMMARY=$(cat .audit-reports/security-summary.txt 2>/dev/null || echo "无安全摘要")
          FIX_PREVIEW=$(cat .audit-reports/pnpm-audit-fix-preview.txt 2>/dev/null || echo "无修复预览")
          FIX_LOG=$(cat .audit-reports/fix-log.txt 2>/dev/null || echo "无修复日志")
          AI_COMMANDS=$(cat .audit-reports/ai-fix-commands.txt 2>/dev/null || echo "无 AI 修复命令")
          AI_EXECUTION=$(cat .audit-reports/ai-fix-execution.txt 2>/dev/null || echo "无 AI 执行日志")
          LOCKFILE_SYNC=$(cat .audit-reports/final-lockfile-sync.txt 2>/dev/null || echo "无锁文件同步日志")
          BUILD_CHECK=$(cat .audit-reports/build-check.txt 2>/dev/null || echo "无构建检查日志")
          INITIAL_LOCKFILE_STATUS=${LOCKFILE_FIXED:-false}
          
          PROMPT="请为我生成一个详细的安全审计报告，格式为 Markdown。报告日期：$CURRENT_DATE

          请基于以下信息进行分析：

          ## pnpm audit 结果
          \`\`\`
          $SECURITY_ISSUES
          \`\`\`

          ## 安全漏洞摘要
          \`\`\`
          $SECURITY_SUMMARY
          \`\`\`

          ## 自动修复预览
          \`\`\`
          $FIX_PREVIEW
          \`\`\`

          ## AI 自动修复日志
          \`\`\`
          $FIX_LOG
          \`\`\`

          ## AI 智能修复命令
          \`\`\`
          $AI_COMMANDS
          \`\`\`

          ## AI 修复执行结果
          \`\`\`
          $AI_EXECUTION
          \`\`\`

          ## 锁文件同步日志
          \`\`\`
          $LOCKFILE_SYNC
          \`\`\`

          ## 构建兼容性检查
          \`\`\`
          $BUILD_CHECK
          \`\`\`

          ## 初始锁文件状态
          初始锁文件修复状态: $INITIAL_LOCKFILE_STATUS

          请生成一个包含以下部分的 Markdown 报告：
          1. 执行摘要（包含初始锁文件状态和多层 AI 自动修复状态）
          2. 安全漏洞分析（重点分析 pnpm audit 结果）
          3. 多策略自动修复报告（标准修复 + 依赖更新 + 强制修复 + AI 智能修复）
          4. AI 智能修复分析（AI 生成的修复命令和执行结果）
          5. 锁文件同步和部署兼容性（解决 Vercel 部署问题）
          6. 构建兼容性验证
          7. 剩余安全问题（如果有未修复的漏洞）
          8. 修复建议和后续行动

          特别注意：
          - 系统使用了多层修复策略：标准修复 → 依赖更新 → 强制修复 → AI 智能分析修复 → 锁文件同步
          - 每次修复后都会执行 pnpm install --no-frozen-lockfile 确保锁文件一致性
          - 重点关注修复后的 Vercel 部署兼容性
          - 如果发现 critical 或 high 级别的安全漏洞，请在报告开头突出显示
          - 重点评估 AI 智能修复的效果和创新性
          - 分析锁文件更新对部署流程的影响
          - 对于未修复的漏洞，提供具体的 pnpm 命令修复建议

          请确保报告专业、详细且具有可操作性。时间戳：$TIMESTAMP"

          # 生成 AI 审计报告
          MAX_RETRIES=3
          RETRY_COUNT=0
          SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" = "false" ]; do
            echo "尝试第 $((RETRY_COUNT + 1)) 次生成安全审计报告..."
            
            timeout 180s bash -c "echo '$PROMPT' | gemini" > /tmp/audit_output.txt 2>&1
            EXIT_CODE=$?
            
            OUTPUT=$(cat /tmp/audit_output.txt 2>/dev/null || echo "")
            
            if [ $EXIT_CODE -eq 0 ] && [ ${#OUTPUT} -gt 500 ]; then
              echo "✅ AI 安全审计报告生成成功"
              
              # 清理输出并保存到 public/data
              echo "$OUTPUT" | sed '/^```markdown/d' | sed '/^```$/d' | sed '/^```/d' > .audit-reports/ai-audit-report.md
              
              # 添加报告头部信息
              cat > public/data/security-audit-report.md << EOF
          # 安全审计报告

          **生成时间**: $(date '+%Y-%m-%d %H:%M:%S UTC')  
          **审计周期**: $(date -d '7 days ago' '+%Y-%m-%d') 至 $(date '+%Y-%m-%d')  
          **项目**: $(basename $(pwd))  
          **AI 修复状态**: ${AUTO_FIX_STATUS:-unknown}  
          **初始锁文件状态**: ${INITIAL_LOCKFILE_STATUS}

          ---

          EOF
              cat .audit-reports/ai-audit-report.md >> public/data/security-audit-report.md
              
              SUCCESS=true
            else
              echo "❌ AI 审计报告生成失败，退出码: $EXIT_CODE"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                WAIT_TIME=$((30 + RETRY_COUNT * 30))
                echo "等待 $WAIT_TIME 秒后重试..."
                sleep $WAIT_TIME
              fi
            fi
          done
          
          # 如果 AI 生成失败，创建基础报告
          if [ "$SUCCESS" = "false" ]; then
            echo "⚠️ AI 生成失败，创建基础安全审计报告..."
            cat > public/data/security-audit-report.md << EOF
          # 安全审计报告

          **生成时间**: $(date '+%Y-%m-%d %H:%M:%S UTC')  
          **审计周期**: $(date -d '7 days ago' '+%Y-%m-%d') 至 $(date '+%Y-%m-%d')  
          **项目**: $(basename $(pwd))  
          **状态**: 基础报告 (AI 分析暂时不可用)
          **AI 修复状态**: ${AUTO_FIX_STATUS:-unknown}  
          **初始锁文件状态**: ${INITIAL_LOCKFILE_STATUS}

          ## 执行摘要

          本周安全审计已完成，详细分析请查看各项检查结果。

          ## pnpm audit 结果

          \`\`\`
          $SECURITY_ISSUES
          \`\`\`

          ## 安全漏洞摘要

          \`\`\`
          $SECURITY_SUMMARY
          \`\`\`

          ## 自动修复预览

          \`\`\`
          $FIX_PREVIEW
          \`\`\`

          ## AI 自动修复日志

          \`\`\`
          $FIX_LOG
          \`\`\`

          ## AI 智能修复命令

          \`\`\`
          $AI_COMMANDS
          \`\`\`

          ## AI 修复执行结果

          \`\`\`
          $AI_EXECUTION
          \`\`\`

          ## 锁文件同步日志

          \`\`\`
          $LOCKFILE_SYNC
          \`\`\`

          ## 构建兼容性检查

          \`\`\`
          $BUILD_CHECK
          \`\`\`

          ---
          *报告由自动化安全审计系统生成*
          EOF
          fi
          
          rm -f /tmp/audit_output.txt
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}

      - name: Check for Critical Issues
        run: |
          echo "=== 检查是否需要创建 GitHub Issue ==="
          
          CRITICAL_ISSUES=false
          
          # 检查高危安全漏洞
          if grep -q "high\|critical" .audit-reports/pnpm-audit.txt 2>/dev/null; then
            CRITICAL_ISSUES=true
            echo "发现高危安全漏洞"
          fi
          
          # 如果自动修复成功，降低 Issue 创建的紧急程度
          if [ "$CRITICAL_ISSUES" = "true" ] && [ "$AUTO_FIX_STATUS" != "complete" ]; then
            echo "NEED_ISSUE=true" >> $GITHUB_ENV
            echo "发现严重问题且未完全自动修复，将创建 GitHub Issue"
          elif [ "$AUTO_FIX_STATUS" = "failed" ]; then
            echo "NEED_ISSUE=true" >> $GITHUB_ENV
            echo "自动修复失败，将创建 GitHub Issue"
          else
            echo "NEED_ISSUE=false" >> $GITHUB_ENV
            echo "问题已自动修复或未发现严重问题"
          fi

      - name: Create Issue for Critical Problems
        if: env.NEED_ISSUE == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const auditReport = fs.readFileSync('public/data/security-audit-report.md', 'utf8');
            const autoFixStatus = process.env.AUTO_FIX_STATUS || 'unknown';
            const securityFixed = process.env.SECURITY_FIXED === 'true';
            
            let title = `🚨 安全审计发现问题 - ${new Date().toISOString().split('T')[0]}`;
            let labels = ['security', 'audit', 'automated'];
            
            if (autoFixStatus === 'failed') {
              title = `❌ 安全问题自动修复失败 - ${new Date().toISOString().split('T')[0]}`;
              labels.push('fix-failed', 'critical');
            } else if (autoFixStatus === 'partial') {
              title = `⚠️ 部分安全问题未修复 - ${new Date().toISOString().split('T')[0]}`;
              labels.push('partial-fix', 'medium');
            } else {
              labels.push('critical');
            }

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: `## 自动安全审计${securityFixed ? '和修复' : ''}报告

            本次安全审计${securityFixed ? '已尝试自动修复安全问题，但' : ''}发现了需要关注的安全漏洞。

            ### AI 自动修复状态
            - **修复状态**: ${autoFixStatus}
            - **安全问题**: ${securityFixed ? '已尝试修复' : '未修复'}

            ### 审计报告摘要

            ${auditReport.substring(0, 2000)}...

            [查看完整报告](public/data/security-audit-report.md)

            ### 建议行动

            ${autoFixStatus === 'failed' ? 
              '1. 检查自动修复失败的原因\\n2. 手动执行 \`pnpm audit --fix\`\\n3. 更新依赖版本' :
              autoFixStatus === 'partial' ?
              '1. 检查剩余的安全漏洞\\n2. 手动更新无法自动修复的依赖\\n3. 验证修复效果' :
              '1. 立即检查安全漏洞\\n2. 手动执行 \`pnpm audit --fix\`\\n3. 更新依赖版本'
            }

            ---
            *此 Issue 由自动化安全审计和修复系统创建*`,
                          labels: labels
                        });

      - name: Set commit message
        run: |
          if [ "$SECURITY_FIXED" = "true" ] && [ "$LOCKFILE_FIXED" = "true" ]; then
            echo "COMMIT_MESSAGE=Security Audit + Auto-fix + Lockfile Sync" >> $GITHUB_ENV
          elif [ "$SECURITY_FIXED" = "true" ]; then
            echo "COMMIT_MESSAGE=Security Audit + Auto-fix" >> $GITHUB_ENV
          elif [ "$LOCKFILE_FIXED" = "true" ]; then
            echo "COMMIT_MESSAGE=Security Audit + Lockfile Sync" >> $GITHUB_ENV
          else
            echo "COMMIT_MESSAGE=Security Audit Report" >> $GITHUB_ENV
          fi

      - name: Commit Security Reports and Fixes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: ${{ env.COMMIT_MESSAGE }}
          file_pattern: "public/data/security-audit-report.md package.json pnpm-lock.yaml"
          commit_user_name: "Security Audit Bot"
          commit_user_email: "security-audit-bot@users.noreply.github.com"

      - name: Summary
        run: |
          echo "=== 安全审计完成摘要 ==="
          echo "✅ pnpm audit 安全扫描完成"
          echo "✅ AI 自动修复尝试完成"
          echo "✅ 安全审计报告生成完成"
          echo ""
          echo "📊 修复状态: ${AUTO_FIX_STATUS:-unknown}"
          echo "🔒 安全修复: ${SECURITY_FIXED:-false}"
          echo ""
          echo "🔍 查看详细报告: public/data/security-audit-report.md"